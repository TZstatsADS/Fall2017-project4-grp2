---
title: "Untitled"
author: "Tiantian Chen (tc2818)"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,warning=FALSE}

library(magrittr)
library(dplyr)

## read data ##
setwd("~/Google Drive/Course | ADS/Project 4/data_sample/eachmovie_sample")
eachmovie<-read.csv("data_train.csv",header = T)
eachmovie_test<-read.csv("data_test.csv",header = T)
dim(eachmovie)

```


```{r}

# a function to generate a group of random numnbers whose sum equals to 1
sample_sum1<-function(number=6){
  #input--number: amount of random numbers
  #input--sum: the sum of random numbers generated
  sample1<- sort(runif((number-1)))
  sample2<-c(sample1[1],diff(sample1),1-sample1[number-1])
  return(sample2)
}


ClusterModel<-function(dataset, C){
  
  ### STEP 1: initial guess for mu and gamma ###
  mu <- sample_sum1(C)
  sample_jc <- replicate(length(unique(dataset$Movie))*C,sample_sum1())

  Movie_set <- unique(dataset$Movie)
  K <- 6
  gamma_est <- array(data = sample_jc, dim = c(K, length(Movie_set), C), # array: k j c
                     dimnames = list(
                       c(1:K), 
                       Movie_set,
                       c(1:C)
                     ))
  
  ### STEP 2 ###
  N <-length(unique(dataset$User)) # N= 5055
  
  Pi_est<-matrix(NA, nrow=N, ncol = C)
  rownames(Pi_est)<-c(unique(dataset$User))
  for(i in unique(dataset$User)){
    product<-rep(NA, C)
    for(c in 1:C){
      subdata<-dataset[dataset$User==i,]
      product[c] <- 1
      for(j in unique(subdata$movie)){
        k<-subdata[subdata$movie == j,4]
        g_est<-gamma_est[k,dimnames(gamma_est)[[2]]==j,c] 
        product[c]<-product*g_est
      }
    }
    s<- sum(mu*product)
    Pi_est[rownames(Pi_est)==i,]<-mu*product/s
  }
  
  ### STEP 3 & 4: iteration to update parameters ###
  
  change_mu <- 1
  change_gamma <- 1
 
  while(change_mu >0.01 & change_gamma > 0.01){
    mu_old<-mu  
    gamma_est_old<-gamma_est
    
    ## update mu
    for(c in 1:C){
      mu[c] = sum(Pi_est[,c])/N
    }
  
    ## update gamma estimation
    for(k in 1:6){
      for(c in 1:C){
       for(j in unique(dataset$Movie)){
      
         sub_j<-dataset[dataset$Movie==j,]
         # find user who have scored movie j
         set_of_i<- unique(sub_j$User)
       
         sum_1<-0
         sum_2<-0
         for(i in set_of_i){
           sum_1 <- sum_1+Pi_est[rownames(Pi_est)==i,c]*(sub_j$Score[sub_j$User==i]==k)
           sum_2<-sum_2+Pi_est[rownames(Pi_est)==i,c]
           }
         gamma_est[k,sum(unique(dataset$movie)<=j),c]<-sum_1/sum_2
       }}}
    
    ### update Pi
      for(i in unique(dataset$User)){
        product<-rep(NA, C)
        for(c in 1:C){
          subdata<-dataset[dataset$User==i,]
          product[c] <- 1
          for(j in unique(subdata$movie)){
            k<-subdata[subdata$movie == j,4]
            g_est<-gamma_est[k,dimnames(gamma_est)[[2]]==j,c] 
            product[c]<-product*g_est
          }
        }
        s<- sum(mu*product)
        for(c in 1:C){
          Pi_est[as.character(i),c]<-mu[c]*product[c]/s
        }
        }
    
    
  
   ## calculate the change of mu and gamma
    change_mu<-norm(as.matrix(mu-mu_old), 'f')
    change_gamma<-norm(as.matrix(gamma_est-gamma_est_old),'f')
  }
  
  ## return parameters
  return(list(mu, gamma_est))
}


### function to calculate the expectation of score ###

EstimateScore<-function(i1,b,dataset3,para1){
  # input i1: user id; input b: movie id
  
  if(!any(b==unique(dataset3$Movie))){return(NA)}
  mu_from_em<-para1[[1]]
  gamma_from_em<-para1[[2]]
  expect_score <- 0
  for(k in 1:6){
    sum_up <- 0
    sum_down <- 0
    for(cc in 1:dim(gamma_from_em)[3]){
    gamma_c<-gamma_from_em[,,cc]
    I_i <- dataset3$Movie[dataset3$User == i1]
    pd <- 1
    for(j in I_i){
      pd <- pd*gamma_c[dataset3$Score[dataset3$User==i1 & dataset3$Movie==j],as.character(j)]
      }
    sum_up <- sum_up + mu_from_em[cc]*gamma_c[k,as.character(b)] *(pd+0.0000001)
    sum_down <- sum_down + mu_from_em[cc]*(pd+0.0000001)
    }
    expect_score <- expect_score + k*sum_up/sum_down
  }
  return(expect_score)
}


groupShuffleSplit <- function(df, grp_col, train_ratio=0.8, seed=NULL){
  # input
  #   df      : (data.frame) dataset
  #   grp_col : (string) the name of the factor column to be split
  #   train_ratio : (float) the ratio of the training set in dataset
  # output
  #   train_idx: (vector) the index of the training set in all dataset 
  set.seed(seed)
  train_set <- (df %>% split(df[grp_col]) 
                %>% lapply(function(df){ return(df[sample(nrow(df), nrow(df)*train_ratio), ]) }) 
                %>% lapply(function(df){ return(cbind(idx = as.numeric(rownames(df)), df)) }) 
                %>% bind_rows()
  )
  return(c(train_set$idx))
}



### cross-validation for choosing C
CV_Movie <- function(fold=5, dataset2, C_list){
  
  n = nrow(dataset2)
  c_number<-length(C_list)
  error_c <-rep(NA, c_number)
  result_para<-vector("list",c_number)
  
  for(count in 1:c_number){
        
    train_idx<-groupShuffleSplit(dataset2, grp_col = "User")
    test_data<-dataset2[-train_idx,]
    train_data<-dataset2[train_idx,]
      
    result_para[[count]]<- ClusterModel(train_data,C_list[count])
      
    #calculate error
    test_data$est_score<-apply(test_data,1,function(x){return(EstimateScore(x[3],x[2],train_data,result_para[[count]]))})
    
    
    # #criterion 1: accuracy (error_fold)
    # error_fold[fold]<-sum(test_data$score == test_data$expectation_score)/(n/5)
    
    #criterion 2: MAE
    row_na<-is.na(test_data$est_score)
    error_c[count]<-sum(abs(test_data$Score[!row_na] - test_data$est_score[!row_na]))/(nrow(test_data)-sum(row_na))

    # #criterion 3: ROC
    # n=0;
    # m=0;
    # for(i in 1:nrow(test_data)){
    # if(test_data[i,4]>3 & test_data[i,5]>3){
    #  n=n+1
    # }else if(test_data[i,4]>3 & test_data[i,5]<=3){
    #   m=m+1
    #  }
    # }
    # error3_fold[fold]<- n / (n+m)
    
  }
  
  C_best<-C_list[which.min(error_c)]
  mu_best<-result_para[[which.min(error_c)]][[1]]
  gamma_best <- result_para[[which.min(error_c)]][[2]]
  
  return(list(C_best,mu_best,gamma_best))
}

mae <- function(pred, y){
  return(sum(abs(pred-y),na.rm = T))
}


```

```{r}

cv_result<-CV_Movie(dataset2 = eachmovie[1:1145,],C_list =  c(4:5))
final_para<-ClusterModel(eachmovie[1:1145,],cv_result[[1]])


est_score<-apply(eachmovie_test[1:10,],1,function(x){return(EstimateScore(x[3],x[2],eachmovie[1:1145,],final_para))})


mae(est_score,eachmovie_test$Score[1:10])

roc_rm_na<-function(pred2,y2){
  n=0
  m=0
  y2<-y2[!is.na(pred2)]
  pred2<-pred2[!is.na(pred2)]
  for(i2 in 1:length(y2)){
  if(y2[i2]>3 & pred2[i2]>3){n=n+1}
  else if(y2[i2]>3 & pred2[i2]<=3){m=m+1}
  }
  return(n/(n+m))
}

roc_rm_na(est_score,eachmovie_test$Score[1:10])



```
